# SWEA 2383 점심 식사시간

## 접근법

DFS

### why?

1. 사람들이 이동함에 따라 대기하는 시간이 달라지기 때문에, 경우의 수가 다양해져서 최적의 케이스를 그리디하게 판단할 수 없기 때문이다.
2. TODO. 각 사람들이 가장 가까운 계단을 선택하는 그리디한 접근을 시도하여 최소 시간을 미리 계산해둔 후,
   이후 개별 사람이 각 계단에 소요되는 시간이 그리디한 최소 시간보다 크다면 백트래킹이 가능하다. 하지만 이게 많은 가지를 줄여줄지는 의문이다.

> review point
> 결국 개별 사람들의 소요 시간을 미리 계산해두었다. 우선 순위 큐를 활용해야 했기 때문이다.

## 구현

### Input

1. 사람들을 좌표 속성 값을 지니고 있는 객체로 다루고 인스턴스 배열에 담는다.
   사람 배열을 순회하면서 선택에 따른 DFS를 하기 위함이다.
2. 두 계단의 위치와 시간 또한 객체화 하여 두 개의 변수로 저장한다.
   추후 사람마다 걸리는 시간을 계산할 때 바로 참조하기 위함이다.

### DFS

1. 두 파트로 사람들을 모으기 위해서 boolean[] 배열을 다룬다.
2. DFS 로 두 집합을 만든 후, 소요 시간을 계산한다.
3. 두 집합의 소요시간 중 가장 긴 값을, 최종 최소 소요 시간과 비교하여 갱신한다.

### 소요 시간 계산

1. 만약 한 사람이 소요되는 시간이 이미 계산된 최소 시간보다 큰 경우 탐색을 중단한다.
2. 각 계단은 걸릴 수 있는 시간을 인덱스로 가지는 배열을 가진다.
3. 배정된 사람은 각자 걸리는 시간의 인덱스부터 계단의 소요 시간만큼의 인덱스까지의 값을 1씩 증가시킨다.
4. 해당 배열을 순회하면서 크기가 3보다 큰 경우, 그 초과분을 다음 인덱스에 증가시킨다.
5. 마지막으로 1이 존재하는 인덱스가 그 계단에서의 최종 소요 시간이다.

> review point
> 우선 순위 큐를 활용해서 각 파트의 총 소요 시간을 계산해야만 했다.
> 인덱스를 순회하며 3보다 초과하는 크기 만큼을 뒤로 넘기는 것은 실제 동작을 반영하지 않는다.
> 이월 대상이 한 사람이고 6만큼이 초과분인 경우, 실제로 6만큼 뒤 개월로 밀려야하지만 3만큼 쪼개져서 이월되면 원래만큼 이월되지 않는다.
