# 게리맨더링

## 접근 방식
 - 각 정점 간의 이어져 있는 간선 정보를 edge 형태로 입력 받아 Arraylist에 저장한다.
 - 인접행렬로 가공
 - 주어지는 N개의 선거구의 모든 부분 집합을 구하고, visited 처리 된 선거구는 team1, 나머지는 team2
 - 각 선거구가 연결 되어 있는지 확인
 - 인접행렬로, team1[1,2,3,6] 일때 1-2-3-6 순으로 
 	-adj[1][2] == 1, adj[2][3] == 1, adj[3][6] == 1 이렇게 확인했으나
 	- **3과 6이 이어져 있지 않더라도 2가 3과 6의 중간다리 역할을 한다면 1,2,3,6은 이어져 있다고 판단한다.**
 	- **하지만 인접행렬을 통해 판단할경우 1-2-3 / 6 으로 끊어져있다고 판단하므로 다른 연결 확인 방식을 찾아보자...**
 	

 ### 09.07. 02:00
 ```
 static void team1Valid() {
		boolean[] addCheck = new boolean[N + 1];

		connected1 = true;
//		System.out.println("팀1 사이즈 = " + team1.size());
		Queue<int[]> queue = new LinkedList<>();
		

		queue.add(adj[team1.get(0)]);
		addCheck[team1.get(0)] = true;

		while (!queue.isEmpty()) {
			int curr[] = queue.poll();
			for (int i : curr) {
				if (!addCheck[i] && team1.contains(i)) {
					queue.add(adj[i]);
					addCheck[i] = true;
					team1.remove(i);
				}
			}
		}
		if (team1.isEmpty()) {
			connected1 = true;
		} else {
			connected1 = false;
		}
	}
```
** 선거구 내에서 구역 간 연결을 확인하는 메소드에서, queue에 넣고 빼낸 원소를 team1이 갖고 있으면 team1에서 지워주면서
큐가 다 비워졌을 때, team1이 비어있으면 연결 되어 있다고 판단하는 로직 **
** 그러나 team1의 원본 배열의 원소를 삭제했기 때문에 , 후속에서 진행 될 team1 원소를 이용한 인구수 계산을 하지 못함 **
** 그러므로 team1 원본 배열을 복사한 하나의 copyTeam1을 만들고 contain --> remove를 거쳐야 하지만, contain과 remove는 시간복잡도
O(n)을 가지므로 비효율적이라는 gpt4의 충고로 삭제 하는 것이 아닌 방문 배열을 업데이트하며 관리하는 방식으로 전환 **
